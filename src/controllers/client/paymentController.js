const {
  Order,
  Notification,
  sequelize,
  PaymentMethod,
  User,
} = require("../../models");
const crypto = require("crypto");
const sendEmail = require("../../utils/sendEmail");
const Stripe = require("stripe");

const stripe = Stripe(process.env.STRIPE_SECRET_KEY);
const axios = require("axios");
const momoService = require("../../services/client/momoService");
const zaloPayService = require("../../services/client/zalopayService");
const vnpayService = require("../../services/client/vnpayService");
const viettelMoneyService = require("../../services/client/viettelMoneyService");
const refundGateway = require("../../utils/refundGateway");
const payos = require("../../services/client/payosSdkService"); // SDK m·ªõi
function verifyPayosSignature(payload, signature, secretKey) {
  const hmac = crypto.createHmac("sha256", secretKey);
  hmac.update(JSON.stringify(payload));
  return hmac.digest("hex") === signature;
}

const moment = require("moment");

const { Op } = require("sequelize");

class PaymentController {
  static async momoPay(req, res) {
    try {
      const { orderId } = req.body;
      const order = await Order.findByPk(orderId);

      if (!order)
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });

      const momoOrderId = order.orderCode;

      const momoRes = await momoService.createPaymentLink({
        orderId: momoOrderId,
        amount: order.finalPrice,
        orderInfo: `Thanh to√°n ƒë∆°n h√†ng ${order.orderCode}`,
      });

      if (momoRes.resultCode !== 0) {
        return res.status(400).json({
          message: "L·ªói t·∫°o thanh to√°n MoMo",
          momoRes,
        });
      }

      order.momoOrderId = momoOrderId;
      order.paymentStatus = "waiting";
      await order.save();

      return res.json({ payUrl: momoRes.payUrl });
    } catch (error) {
      console.error("MoMo error:", error);
      return res
        .status(500)
        .json({ message: "L·ªói khi t·∫°o link thanh to√°n MoMo" });
    }
  }

  static async momoCallback(req, res) {
  const start = Date.now();
  try {
    const ip =
      (req.headers["x-forwarded-for"] || "")
        .toString()
        .split(",")[0]
        .trim() ||
      req.ip ||
      req.connection?.remoteAddress ||
      "";
    const hasBody = Object.keys(req.body || {}).length > 0;
    const data = hasBody ? req.body : req.query;

    const {
      orderId,
      resultCode,
      transId,
      amount,
      requestId,
      partnerCode,
      payType,
      message,
      signature,
    } = data || {};
    const isSuccess = Number(resultCode) === 0;

  

    if (!isSuccess) {
      console.warn(`[MoMo CALLBACK] resultCode=${resultCode} != 0 -> skip update.`);
      return res.type("text/plain").end("OK");
    }

    let order =
      (await Order.findOne({ where: { momoOrderId: orderId } })) ||
      (await Order.findOne({ where: { orderCode: orderId } }));

    if (!order) {
      console.warn("[MoMo CALLBACK] ORDER_NOT_FOUND:", orderId);
      return res.type("text/plain").end("ORDER_NOT_FOUND");
    }

    if (amount != null) {
      const ipnAmount = Number(amount);
      const dbAmount = Number(order.finalPrice);
      if (!Number.isNaN(ipnAmount) && !Number.isNaN(dbAmount)) {
        if (ipnAmount !== dbAmount) {
         
          return res.type("text/plain").end("OK");
        }
      }
    }

    if (order.paymentStatus === "paid") {
     
      return res.type("text/plain").end("OK");
    }

    // ====== C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI ======
    let momoTransId = transId;
    if (!momoTransId) {
   
      try {
        const queryRes = await momoService.queryTransaction({
          orderId,
          requestId: requestId || `${orderId}-${Date.now()}`
        });
        if (queryRes.resultCode === 0 && queryRes.transId) {
          momoTransId = queryRes.transId;
         
        } else {
          
        }
      } catch (err) {
        
      }
    }

    order.paymentStatus = "paid";
    order.paymentMethod = "MOMO";
    order.momoTransId = momoTransId || null;
    order.paymentTime = new Date();
    await order.save();

   

    // ====== TH√îNG B√ÅO ======
    const slug = `order-${order.orderCode}`;
    const existingNoti = await Notification.findOne({ where: { slug } });
    if (existingNoti) {
      existingNoti.title = "Thanh to√°n th√†nh c√¥ng";
      existingNoti.message = `ƒê∆°n h√†ng <strong>${order.orderCode}</strong> ƒë√£ ƒë∆∞·ª£c thanh to√°n qua MoMo.`;
      existingNoti.startAt = new Date();
      existingNoti.isActive = true;
      await existingNoti.save();
      
    } else {
      await Notification.create({
        userId: order.userId,
        title: "Thanh to√°n th√†nh c√¥ng",
        message: `ƒê∆°n h√†ng <strong>${order.orderCode}</strong> ƒë√£ ƒë∆∞·ª£c thanh to√°n qua MoMo.`,
        slug,
        type: "order",
        referenceId: order.id,
        link: `/user-profile?orderCode=${order.orderCode}`,
        startAt: new Date(),
        isActive: true,
      });
      
    }

    // ====== K·∫æT TH√öC ======
return res.json({
  message: "OK",
  order,  // üëà g·ª≠i lu√¥n th√¥ng tin ƒë∆°n ƒë√£ update
});

  } catch (err) {
 
    return res.status(500).type("text/plain").end("ERROR");
  } finally {
    console.log("[MoMo CALLBACK] done in", Date.now() - start, "ms");
  }
}


  static async zaloPay(req, res) {
    try {
      const { orderId } = req.body;
      const order = await Order.findByPk(orderId);
      if (!order)
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });

      const zaloRes = await zaloPayService.createPaymentLink({
        orderId: order.orderCode,
        amount: order.finalPrice,
        orderInfo: order.orderCode,
      });
      

      if (zaloRes.return_code !== 1) {
        return res
          .status(400)
          .json({ message: "L·ªói t·∫°o thanh to√°n ZaloPay", zaloRes });
      }

      // Optionally: l∆∞u zaloOrderId n·∫øu c·∫ßn
      // order.zaloOrderId = zaloRes.app_trans_id;
      // await order.save();

      return res.json({ payUrl: zaloRes.order_url });
    } catch (err) {
      console.error("ZaloPay error:", err);
      return res
        .status(500)
        .json({ message: "L·ªói server khi t·∫°o thanh to√°n ZaloPay" });
    }
  }
  static async zaloCallback(req, res) {
    try {
     

      const rawData = req.body?.data || "{}";
      const parsedData = JSON.parse(rawData);

     

      const { embed_data, zp_trans_id, app_trans_id } = parsedData;
     

      // ‚úÖ L·∫•y orderCode t·ª´ embed_data
      let orderCode = null;
      try {
        const embed = JSON.parse(embed_data);
        orderCode = embed.orderCode;
      } catch (err) {
        
      }

      if (!orderCode) {
        
        return res.status(400).send("Thi·∫øu orderCode");
      }

      const order = await Order.findOne({ where: { orderCode } });
      if (!order) {
       
        return res.status(404).send("Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng");
      }

      // ‚úÖ C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n
      order.paymentStatus = "paid";
      order.paymentTime = new Date();
      if (zp_trans_id) order.zaloTransId = zp_trans_id;
      if (app_trans_id) order.zaloAppTransId = app_trans_id; // ‚Üê TH√äM D√íNG N√ÄY
      await order.save();
      

      const redirectUrl = `${process.env.BASE_URL}/order-confirmation?orderCode=${order.orderCode}`;
      return res.redirect(redirectUrl);
    } catch (err) {
      console.error("‚ùå L·ªói x·ª≠ l√Ω ZaloPay callback:", err);
      return res.status(500).send("Server Error");
    }
  }

  static async vnpay(req, res) {
    try {
      const { orderId } = req.body;
      const { bankCode } = req.body;
      const order = await Order.findByPk(orderId);
      if (!order)
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });

      const payUrl = vnpayService.createPaymentLink({
        orderId: order.orderCode,
        amount: order.finalPrice,
        orderInfo: order.orderCode,
        bankCode, // ‚úÖ TRUY·ªÄN TH·∫∞NG N√ÄY
      });

      return res.json({ payUrl });
    } catch (err) {
      console.error("VNPay error:", err);
      return res
        .status(500)
        .json({ message: "L·ªói server khi t·∫°o thanh to√°n VNPay" });
    }
  }
  // trong OrderController
  static async vnpayCallback(req, res) {
    try {
      const raw = req.body.rawQuery;
      const isFromFrontend = Boolean(raw);

      // Parse query params (raw t·ª´ FE fetch ho·∫∑c query t·ª´ redirect)
      const qs = raw
        ? require("querystring").parse(raw, null, null, {
            decodeURIComponent: (v) => v, // KH√îNG decode 2 l·∫ßn
          })
        : req.query;

      const vnpTxnRef = qs.vnp_TxnRef; // ƒê√¢y l√† vnpOrderId
      const rspCode = qs.vnp_ResponseCode;
      const secureHash = qs.vnp_SecureHash;

    
      // 1. Ki·ªÉm tra ch·ªØ k√Ω
      const isValid = vnpayService.verifySignature(qs, secureHash);
      if (!isValid) {
       
        return res.status(400).end("INVALID_CHECKSUM");
      }

      // 2. T√¨m ƒë∆°n theo vnpOrderId
      const order = await Order.findOne({
        where: {
          vnpOrderId: {
            [Op.like]: `${vnpTxnRef}%`, // d√πng LIKE ƒë·ªÉ match b·∫£n ghi c√≥ th√™m timestamp
          },
        },
      });
      if (!order) {
        
        return res.status(404).end("ORDER_NOT_FOUND");
      }

      // 3. N·∫øu thanh to√°n th√†nh c√¥ng
      if (rspCode === "00") {
        order.paymentStatus = "paid";
        order.paymentTime = new Date();
        order.vnpTransactionId = qs.vnp_TransactionNo;

       
        order.vnpPayDate = moment(qs.vnp_PayDate, "YYYYMMDDHHmmss").toDate();
       
        await order.save();
       
      } else {
        // Gi·ªØ tr·∫°ng th√°i "waiting", ƒë·ªÉ CRON x·ª≠ l√Ω sau ho·∫∑c cho ph√©p thanh to√°n l·∫°i
        
      }

     if (isFromFrontend) {
  return res.json({
    message: "OK",
    order,   // üëà g·ª≠i v·ªÅ lu√¥n order ƒë√£ c·∫≠p nh·∫≠t
  });
}


      // 5. N·∫øu redirect t·ª´ VNPay ‚Üí ƒëi·ªÅu h∆∞·ªõng v·ªÅ trang x√°c nh·∫≠n
      const redirectUrl = `${process.env.BASE_URL}/order-confirmation?orderCode=${order.orderCode}`;
      return res.redirect(redirectUrl);
    } catch (err) {
     
      return res.status(500).end("ERROR");
    }
  }

  static async stripePay(req, res) {
    try {
      const { orderId } = req.body;
     

      const order = await Order.findByPk(orderId);
      if (!order) {
      
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });
      }
      

      // ƒê·∫£m b·∫£o r·∫±ng process.env.CLIENT_URL c√≥ scheme (http:// ho·∫∑c https://)
      // ƒê√¢y l√† ƒëi·ªÉm m·∫•u ch·ªët ƒë·ªÉ kh·∫Øc ph·ª•c l·ªói "Invalid URL: An explicit scheme must be provided."
      // B·∫°n n√™n ki·ªÉm tra v√† s·ª≠a bi·∫øn m√¥i tr∆∞·ªùng CLIENT_URL trong file .env c·ªßa m√¨nh.
      // V√≠ d·ª•: CLIENT_URL=https://yourdomain.com ho·∫∑c CLIENT_URL=http://localhost:3000
      if (
        !process.env.CLIENT_URL.startsWith("http://") &&
        !process.env.CLIENT_URL.startsWith("https://")
      ) {
        
        return res.status(500).json({
          message:
            "L·ªói c·∫•u h√¨nh URL m√°y kh√°ch. Vui l√≤ng ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng CLIENT_URL.",
        });
      }

      const successUrl = `${process.env.CLIENT_URL}/order-confirmation?orderCode=${order.orderCode}`;
      const cancelUrl = `${process.env.CLIENT_URL}/checkout`;

     

      const session = await stripe.checkout.sessions.create({
        payment_method_types: ["card"],
        mode: "payment",
        line_items: [
          {
            price_data: {
              currency: "vnd",
              unit_amount: Math.round(order.finalPrice), // ƒë∆°n v·ªã nh·ªè nh·∫•t (v√≠ d·ª•: 10000 VND -> 10000)
              product_data: {
                name: `Thanh to√°n ƒë∆°n h√†ng ${order.orderCode}`,
                description: `M√£ ƒë∆°n h√†ng: ${order.orderCode}, T·ªïng ti·ªÅn: ${order.finalPrice} VND`,
              },
            },
            quantity: 1,
          },
        ],
        success_url: successUrl,
        cancel_url: cancelUrl,
        metadata: {
          orderId: order.id,
          orderCode: order.orderCode,
        },
      });

     
      return res.json({ url: session.url });
    } catch (error) {
     
      // Log chi ti·∫øt l·ªói Stripe n·∫øu c√≥
      if (error.type === "StripeInvalidRequestError") {
       
      
      }
      return res.status(500).json({
        message: "Kh√¥ng th·ªÉ t·∫°o session thanh to√°n Stripe",
        error: error.message,
      });
    }
  }
  static async handleStripeWebhook(req, res) {
    console.log("--- [Stripe Webhook] Request Received ---");
    console.log("Headers:", req.headers);
    // req.body ·ªü ƒë√¢y *ph·∫£i* l√† m·ªôt Buffer (d·∫°ng raw), kh√¥ng ph·∫£i JSON ƒë√£ parse
    console.log(
      "Raw Body (should be Buffer/Text):",
      req.body
        ? req.body.toString().substring(0, 500) + "..."
        : "Body is empty/not buffer"
    ); // Log 500 k√Ω t·ª± ƒë·∫ßu c·ªßa body
    console.log("Stripe-Signature Header:", req.headers["stripe-signature"]);

    const sig = req.headers["stripe-signature"];

    let event;
    try {
      // stripe.webhooks.constructEvent c·∫ßn raw body, KH√îNG ph·∫£i JSON ƒë√£ parse
      event = stripe.webhooks.constructEvent(
        req.body, // ƒê·∫£m b·∫£o ƒë√¢y l√† Buffer ho·∫∑c chu·ªói raw
        sig,
        process.env.STRIPE_WEBHOOK_SECRET
      );
      console.log(
        `‚úÖ [Stripe Webhook] Event Constructed Successfully. Type: ${event.type}`
      );
    } catch (err) {
      console.error(
        "‚ùå [Stripe Webhook] Signature Verification Failed or Event Construction Error:",
        err.message
      );
      // Ghi l·∫°i to√†n b·ªô l·ªói n·∫øu c√≥ ƒë·ªÉ debug
      console.error("[Stripe Webhook] Full Error:", err);
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    // X·ª≠ l√Ω c√°c lo·∫°i s·ª± ki·ªán kh√°c nhau
    switch (event.type) {
      case "checkout.session.completed":
        const session = event.data.object;
        const { orderCode, orderId } = session.metadata || {};

        console.log(
          `‚ú® [Stripe Webhook] Checkout Session Completed Event Received!`
        );
        console.log(`Session ID: ${session.id}`);
        console.log(`Payment Status (from Stripe): ${session.payment_status}`);
        console.log(`Metadata - OrderCode: ${orderCode}, OrderID: ${orderId}`);
        console.log(`Customer Email: ${session.customer_details?.email}`);
        console.log(`Amount Total: ${session.amount_total}`); // amount_total l√† cent/vnd, b·∫°n c·∫ßn chia l·∫°i n·∫øu l∆∞u theo ƒë∆°n v·ªã l·ªõn

        if (!orderCode) {
          console.warn(
            `[Stripe Webhook] Metadata 'orderCode' missing from session for Session ID: ${session.id}`
          );
          return res.status(400).send("Metadata orderCode missing.");
        }

        const t = await sequelize.transaction(); // B·∫Øt ƒë·∫ßu transaction
        try {
          const order = await Order.findOne({
            where: { orderCode },
            transaction: t,
          });
          if (!order) {
            console.warn(
              `[Stripe Webhook] Order not found in DB for OrderCode: ${orderCode}`
            );
            await t.rollback();
            return res.status(404).send("Order not found.");
          }
          console.log(
            `[Stripe Webhook] Found Order in DB. Current Status: ${order.status}, PaymentStatus: ${order.paymentStatus}`
          );

          // Ki·ªÉm tra n·∫øu thanh to√°n ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω tr∆∞·ªõc ƒë√≥ ƒë·ªÉ tr√°nh tr√πng l·∫∑p
          if (order.paymentStatus === "paid" && order.status === "processing") {
            console.log(
              `[Stripe Webhook] Order ${orderCode} already marked as paid/processing. Skipping update.`
            );
            await t.commit(); // Commit transaction d√π kh√¥ng thay ƒë·ªïi g√¨
            return res.status(200).send("OK - Already processed.");
          }

          // L·∫•y PaymentMethodId cho Stripe
          // ƒê·∫£m b·∫£o b·∫°n c√≥ m·ªôt record 'Stripe' trong b·∫£ng PaymentMethods c·ªßa m√¨nh
          const stripePaymentMethod = await PaymentMethod.findOne({
            where: { code: "stripe" }, // Gi·∫£ s·ª≠ code cho Stripe l√† 'stripe'
            transaction: t,
          });

          if (!stripePaymentMethod) {
            console.error(
              `[Stripe Webhook] ERROR: PaymentMethod with code 'stripe' not found in database!`
            );
            await t.rollback();
            return res
              .status(500)
              .send(
                "Internal Server Error: Stripe payment method not configured."
              );
          }

          // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
          order.status = "processing"; // Ho·∫∑c 'completed' n·∫øu b·∫°n mu·ªën thanh to√°n xong l√† ho√†n th√†nh lu√¥n
          order.paymentStatus = "paid";
          order.paymentTime = new Date();
          order.stripeSessionId = session.id; // L∆∞u Stripe Session ID
          order.stripePaymentIntentId = session.payment_intent; // ‚úÖ D√≤ng b·∫°n thi·∫øu
          order.paymentMethodId = stripePaymentMethod.id; // G√°n ID ph∆∞∆°ng th·ª©c thanh to√°n Stripe

          await order.save({ transaction: t });
          console.log(
            `[Stripe Webhook] ‚úÖ Order ${orderCode} updated to status '${order.status}' and paymentStatus '${order.paymentStatus}'.`
          );

          // G·ª≠i email x√°c nh·∫≠n, th√¥ng b√°o cho admin, v.v.
          // ... (v√≠ d·ª•: email cho user)
          const user = await order.getUser(); // Gi·∫£ s·ª≠ m·ªëi quan h·ªá User v·ªõi Order
          if (user) {
            const emailHtml = `
                  <h2>ƒê∆°n h√†ng ${
                    order.orderCode
                  } c·ªßa b·∫°n ƒë√£ thanh to√°n th√†nh c√¥ng!</h2>
                  <p>Xin ch√†o ${user.fullName || "kh√°ch h√†ng"},</p>
                  <p>Ch√∫ng t√¥i ƒë√£ nh·∫≠n ƒë∆∞·ª£c thanh to√°n cho ƒë∆°n h√†ng c·ªßa b·∫°n.</p>
                  <p>M√£ ƒë∆°n h√†ng: <b>${order.orderCode}</b></p>
                  <p>T·ªïng ti·ªÅn ƒë√£ thanh to√°n: <b>${order.finalPrice.toLocaleString(
                    "vi-VN"
                  )}‚Ç´</b></p>
                  <p>Ph∆∞∆°ng th·ª©c thanh to√°n: <b>Stripe</b></p>
                  <p>ƒê∆°n h√†ng c·ªßa b·∫°n ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω v√† s·∫Ω s·ªõm ƒë∆∞·ª£c giao.</p>
                  <br />
                  <p>Tr√¢n tr·ªçng,</p>
                  <p>ƒê·ªôi ng≈© h·ªó tr·ª£ PHT Shop</p>
              `;
            try {
              await sendEmail(
                user.email,
                `X√°c nh·∫≠n thanh to√°n ƒë∆°n h√†ng ${order.orderCode} th√†nh c√¥ng!`,
                emailHtml
              );
              console.log(
                `[Stripe Webhook] Email x√°c nh·∫≠n ƒë√£ g·ª≠i cho ${user.email}`
              );
            } catch (emailErr) {
              console.error(
                "[Stripe Webhook] L·ªói g·ª≠i email x√°c nh·∫≠n:",
                emailErr
              );
            }
          }

          await t.commit(); // Commit transaction n·∫øu m·ªçi th·ª© th√†nh c√¥ng
          console.log(
            `[Stripe Webhook] Transaction committed for Order ${orderCode}.`
          );
          return res.status(200).send("OK");
        } catch (err) {
          await t.rollback(); // Rollback transaction n·∫øu c√≥ l·ªói
          console.error(
            `[Stripe Webhook] ‚ùå Error processing checkout.session.completed for OrderCode ${orderCode}:`,
            err
          );
          return res.status(500).send("Server Error processing event.");
        }

      case "payment_intent.succeeded":
        // ƒê√¢y l√† s·ª± ki·ªán cho Payment Intent (n·∫øu b·∫°n d√πng Payment Element/Card Element)
        // Hi·ªán t·∫°i code c·ªßa b·∫°n d√πng Checkout Session, nh∆∞ng n·∫øu m·ªü r·ªông b·∫°n s·∫Ω c·∫ßn c√°i n√†y.
        console.log(
          "‚ú® [Stripe Webhook] Payment Intent Succeeded Event Received."
        );
        console.log("Payment Intent ID:", event.data.object.id);
        // Logic x·ª≠ l√Ω Payment Intent (n·∫øu c√≥)
        return res.status(200).send("OK"); // Tr·∫£ v·ªÅ 200 ƒë·ªÉ Stripe bi·∫øt b·∫°n ƒë√£ nh·∫≠n

      case "payment_intent.payment_failed":
        // X·ª≠ l√Ω khi Payment Intent th·∫•t b·∫°i
        console.log(
          "‚ö†Ô∏è [Stripe Webhook] Payment Intent Failed Event Received."
        );
        console.log("Payment Intent ID:", event.data.object.id);
        // Logic x·ª≠ l√Ω th·∫•t b·∫°i (c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng v·ªÅ failed, g·ª≠i th√¥ng b√°o...)
        return res.status(200).send("OK");

      // Th√™m c√°c tr∆∞·ªùng h·ª£p kh√°c n·∫øu c·∫ßn (v√≠ d·ª•: invoice.payment_succeeded, customer.subscription.created, etc.)
      default:
        console.log(`ü§∑ [Stripe Webhook] Unhandled event type: ${event.type}`);
        // Lu√¥n tr·∫£ v·ªÅ 200 OK cho c√°c s·ª± ki·ªán kh√¥ng x·ª≠ l√Ω ƒë·ªÉ tr√°nh Stripe g·ª≠i l·∫°i nhi·ªÅu l·∫ßn
        return res.status(200).send("OK - Unhandled event type.");
    }
  }

  static async generateVietQR(req, res) {
    try {
      const { accountNumber, accountName, bankCode, amount, message } =
        req.body;

    

      if (!accountNumber || !accountName || !bankCode || !amount || !message) {
       
        return res.status(400).json({ message: "Thi·∫øu th√¥ng tin c·∫ßn thi·∫øt." });
      }

      const encodedMessage = encodeURIComponent(message);

      const vietqrUrl = `https://img.vietqr.io/image/${bankCode}-${accountNumber}-basic.png?amount=${amount}&addInfo=${encodedMessage}`;



      return res.json({
        qrImage: vietqrUrl,
        accountNumber,
        accountName,
        bankCode,
        message,
      });
    } catch (error) {
      console.error(
        "‚ùå [generate VietQR] L·ªói khi sinh QR VietQR:",
        error.message || error
      );
      res.status(500).json({ message: "Kh√¥ng th·ªÉ t·∫°o VietQR." });
    }
  }

  static async payosCallback(req, res) {
    try {
      // Nh·∫≠n d·ªØ li·ªáu t·ª´ c·∫£ webhook (POST JSON) l·∫´n returnUrl (GET/query)
      const { orderCode, status } = req.body?.orderCode ? req.body : req.query;

      if (!orderCode) {
        console.warn("[payosCallback] Thi·∫øu orderCode");
        return res.status(400).json({ message: "Thi·∫øu orderCode" });
      }

      const orderId = Number(orderCode);
      if (isNaN(orderId)) {
        return res.status(400).json({ message: "orderCode kh√¥ng h·ª£p l·ªá" });
      }

      const order = await Order.findByPk(orderId);
      if (!order) {
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });
      }

      // ‚ú® C·∫¨P NH·∫¨T T·∫†M TH·ªúI: Bu·ªôc c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng n·∫øu status l√† 'PAID'
      if (status?.toUpperCase() === "PAID") {
        order.paymentStatus = "paid";
        order.paymentTime = new Date();
        await order.save();
       
      } else {
        
      }

      return res.json({ message: "C·∫≠p nh·∫≠t tr·∫°ng th√°i PayOS th√†nh c√¥ng" });
    } catch (error) {
     
      return res.status(500).json({ message: "L·ªói x·ª≠ l√Ω callback PayOS" });
    }
  }
  static async payosPay(req, res) {
    try {
      const { orderId } = req.body;
      const order = await Order.findByPk(orderId);
      if (!order)
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });

      const finalPrice = Math.round(Number(order.finalPrice));
      if (
        !finalPrice ||
        isNaN(finalPrice) ||
        finalPrice <= 0 ||
        finalPrice > 10000000000
      ) {
        return res
          .status(400)
          .json({ message: "Gi√° tr·ªã thanh to√°n kh√¥ng h·ª£p l·ªá" });
      }

      // ‚úÖ orderCode = ID ƒë∆°n h√†ng (PayOS y√™u c·∫ßu s·ªë < 9007199254740991)
      const safeOrderCode = Number(order.id);

      // L∆∞u orderCode ƒë·ªÉ ƒë·ªëi chi·∫øu khi webhook v·ªÅ
      order.payosOrderId = safeOrderCode;
      order.paymentStatus = "waiting";
      await order.save();

      const payosRes = await payos.createPaymentLink({
        orderCode: safeOrderCode,
        amount: finalPrice,
        description: `ƒê∆°n ${order.orderCode}`,
        returnUrl: `${process.env.BASE_URL}/order-confirmation?orderId=${order.id}`,
        cancelUrl: `${process.env.CLIENT_URL}/checkout`,
        buyerName: order.fullName || "Kh√°ch h√†ng",
        buyerEmail: order.email || "test@example.com",
        buyerPhone: order.phone || "0912345678",
        items: [
          { name: `ƒê∆°n ${order.orderCode}`, quantity: 1, price: finalPrice },
        ],
      });

    
      return res.json({ payUrl: payosRes.checkoutUrl });
    } catch (error) {
     
      return res.status(500).json({ message: "Kh√¥ng th·ªÉ t·∫°o link PayOS" });
    }
  }

  static async payosWebhook(req, res) {
    try {
      const { code, desc, success, data, signature } = req.body;

      // ‚úÖ X√°c th·ª±c ch·ªØ k√Ω ƒë·ªÉ ƒë·∫£m b·∫£o request t·ª´ PayOS
      const isValid = verifyPayosSignature(
        { code, desc, success, data },
        signature,
        process.env.PAYOS_CHECKSUM_KEY
      );

      if (!isValid) {
    
        return res.status(400).json({ message: "Invalid signature" });
      }

      // N·∫øu giao d·ªãch kh√¥ng th√†nh c√¥ng th√¨ b·ªè qua
      if (!success || code !== "00") {
        
        return res.status(400).json({ message: "Giao d·ªãch th·∫•t b·∫°i" });
      }

      const { orderCode, amount, transactionId } = data;

      // ‚úÖ T√¨m ƒë∆°n h√†ng b·∫±ng payosOrderId
      const order = await Order.findOne({ where: { payosOrderId: orderCode } });
      if (!order)
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });

      if (order.paymentStatus !== "paid") {
        order.paymentStatus = "paid";
        order.paymentTime = new Date();
        order.payosTransactionId = transactionId;
        await order.save();

        
      }

      return res.json({ message: "ƒê√£ x·ª≠ l√Ω webhook" });
    } catch (err) {
      console.error("[payosWebhook] ‚ùå L·ªói x·ª≠ l√Ω:", err);
      return res.status(500).json({ message: "L·ªói webhook" });
    }
  }

  static async payAgain(req, res) {
    try {
      const { id } = req.params;
      const { bankCode = "" } = req.body;

      const order = await Order.findByPk(id, {
        include: {
          model: PaymentMethod,
          as: "paymentMethod",
          attributes: ["code"],
        },
      });

      // 1. Ki·ªÉm tra h·ª£p l·ªá
      if (
        !order ||
        order.paymentStatus !== "waiting" ||
        order.status !== "processing"
      ) {
        return res
          .status(400)
          .json({ message: "ƒê∆°n kh√¥ng h·ª£p l·ªá ƒë·ªÉ thanh to√°n l·∫°i" });
      }

      const gateway = order.paymentMethod.code.toLowerCase();
      let payUrl = null;

      switch (gateway) {
        case "momo": {
          const momoOrderId = `${order.orderCode}${Date.now()
            .toString()
            .slice(-6)}`;
          const momoRes = await momoService.createPaymentLink({
            orderId: momoOrderId,
            amount: order.finalPrice,
            orderInfo: `Thanh to√°n l·∫°i ƒë∆°n ${order.orderCode}`,
          });

          if (momoRes.resultCode !== 0)
            return res.status(400).json({ message: "MoMo l·ªói", momoRes });

          order.momoOrderId = momoOrderId;
          payUrl = momoRes.payUrl;
          break;
        }

        case "vnpay": {
          const suffix = moment().format("HHmmss"); // ho·∫∑c Date.now().toString().slice(-6)
          const vnpOrderId = `${order.orderCode}${suffix}`; // KH√îNG D√ôNG D·∫§U `-`

          order.vnpOrderId = vnpOrderId;

          const amount = order.finalPrice;
          const orderInfo = `Thanh to√°n l·∫°i ƒë∆°n ${order.orderCode}`;

          payUrl = vnpayService.createPaymentLink({
            orderId: vnpOrderId,
            amount,
            orderInfo,
            bankCode,
          });

        
          break;
        }

        case "zalopay": {
          const zaloRes = await zaloPayService.createPaymentLink({
            orderId: order.orderCode,
            amount: order.finalPrice,
            orderInfo: order.orderCode,
          });

          if (zaloRes.return_code !== 1)
            return res.status(400).json({ message: "ZaloPay l·ªói", zaloRes });

          payUrl = zaloRes.order_url;
          break;
        }
        case "stripe": {
          const successUrl = `${process.env.CLIENT_URL}/order-confirmation?orderCode=${order.orderCode}`;
          const cancelUrl = `${process.env.CLIENT_URL}/checkout`;

          const session = await stripe.checkout.sessions.create({
            payment_method_types: ["card"],
            mode: "payment",
            line_items: [
              {
                price_data: {
                  currency: "vnd",
                  unit_amount: Math.round(order.finalPrice),
                  product_data: {
                    name: `Thanh to√°n l·∫°i ƒë∆°n h√†ng ${order.orderCode}`,
                    description: `M√£: ${order.orderCode}, T·ªïng ti·ªÅn: ${order.finalPrice} VND`,
                  },
                },
                quantity: 1,
              },
            ],
            success_url: successUrl,
            cancel_url: cancelUrl,
            metadata: {
              orderId: order.id,
              orderCode: order.orderCode,
            },
          });

          order.stripeSessionId = session.id;

          payUrl = session.url;

      
          break;
        }

        case "viettel_money": {
          const billCode = `VT${order.orderCode}${Date.now()
            .toString()
            .slice(-6)}`;
          payUrl = viettelMoneyService.createPaymentLink({
            orderId: order.orderCode,
            billCode,
            amount: order.finalPrice,
            orderInfo: `Thanh to√°n l·∫°i ƒë∆°n ${order.orderCode}`,
          });
          break;
        }
        case "payos": {
          const amount = Math.round(Number(order.finalPrice));
          if (!Number.isSafeInteger(amount) || amount <= 0) {
            return res
              .status(400)
              .json({ message: "Gi√° tr·ªã thanh to√°n kh√¥ng h·ª£p l·ªá" });
          }

          // D√πng lu√¥n order.id l√†m orderCode
          const safeOrderCode = Number(order.id);

          order.paymentStatus = "waiting";

          const payosRes = await payos.createPaymentLink({
            orderCode: safeOrderCode,
            amount,
            description: `ƒë∆°n ${order.orderCode}`,
            returnUrl: `${process.env.BASE_URL}/order-confirmation?orderId=${order.id}`,
            cancelUrl: `${process.env.CLIENT_URL}/checkout`,
            buyerName: order.fullName || "Kh√°ch h√†ng",
            buyerEmail: order.email || "test@example.com",
            buyerPhone: order.phone || "0912345678",
            items: [
              { name: `ƒê∆°n ${order.orderCode}`, quantity: 1, price: amount },
            ],
          });

          payUrl = payosRes.checkoutUrl;
          break;
        }

        default:
          return res.status(400).json({
            message: "Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng h·ªó tr·ª£ thanh to√°n l·∫°i",
          });
      }

      await order.save(); // üíæ L∆∞u vnpOrderId / momoOrderId n·∫øu c√≥

      return res.json({ payUrl });
    } catch (err) {
      console.error("[payAgain]", err);
      return res
        .status(500)
        .json({ message: "Kh√¥ng t·∫°o ƒë∆∞·ª£c link thanh to√°n l·∫°i" });
    }
  }
  static async getPaymentMethods(req, res) {
    try {
      const methods = await PaymentMethod.findAll({
        where: { isActive: true },
        attributes: ["id", "code", "name"],
        order: [["id", "ASC"]],
      });

      return res.json({
        message: "L·∫•y danh s√°ch ph∆∞∆°ng th·ª©c thanh to√°n th√†nh c√¥ng",
        data: methods,
      });
    } catch (err) {
      console.error("[getPaymentMethods] L·ªói:", err);
      return res.status(500).json({
        message: "Kh√¥ng th·ªÉ l·∫•y danh s√°ch ph∆∞∆°ng th·ª©c thanh to√°n",
      });
    }
  }
  static async uploadProof(req, res) {
    try {
      const { id } = req.params;
      if (!req.file || !req.file.path) {
        return res.status(400).json({ message: "Thi·∫øu file ch·ª©ng t·ª´" });
      }

      const order = await Order.findByPk(id);
      if (!order) {
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });
      }

      // L∆∞u URL l√™n tr∆∞·ªùng proofUrl
      order.proofUrl = req.file.path;
      await order.save();

      return res.json({
        message: "Upload ch·ª©ng t·ª´ th√†nh c√¥ng",
        proofUrl: order.proofUrl,
      });
    } catch (err) {
      console.error("L·ªói upload ch·ª©ng t·ª´:", err);
      return res.status(500).json({ message: "Kh√¥ng th·ªÉ upload ch·ª©ng t·ª´" });
    }
  }
}

module.exports = PaymentController;
