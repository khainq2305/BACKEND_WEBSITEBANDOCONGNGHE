const { Notification } = require("../../models");
const { NotificationUser } = require("../../models");
const { Op } = require("sequelize");

const NotificationController = {
  async create(req, res) {
    try {
      const {
        title,
        message,
        link,
        targetType,
        targetId,
        isGlobal = true,
        type,
        isActive = true,
        startAt,
        userIds,
        slug,
      } = req.body;

      const imageUrl = req.file?.path || "";
      // Ki·ªÉm tra tr√πng ti√™u ƒë·ªÅ
      const existing = await Notification.findOne({ where: { title } });
      if (existing) {
        return res
          .status(400)
          .json({ message: "T√™n th√¥ng b√°o n√†y ƒë√£ t·ªìn t·∫°i" });
      }

      let notification;

      try {
        notification = await Notification.create({
          title,
          slug,
          message,
          imageUrl,
          link,
          targetType,
          targetId: targetId ? Number(targetId) : null,
          isGlobal: isGlobal === "true" || isGlobal === true,
          type,
          isActive: isActive === "true" || isActive === true,
          startAt: startAt ? new Date(startAt) : null,
        });
      } catch (err) {
        console.error("L·ªói khi t·∫°o Notification:", err);
        return res
          .status(500)
          .json({ message: "T·∫°o Notification th·∫•t b·∫°i", error: err.message });
      }

      // N·∫øu l√† th√¥ng b√°o cho t·ª´ng user
      if (isGlobal === "false" || isGlobal === false || isGlobal === "0") {
        let parsed = [];

        if (typeof userIds === "string") {
          try {
            parsed = JSON.parse(userIds);
          } catch (err) {
            console.error("userIds parse l·ªói:", userIds);
            return res.status(400).json({ message: "userIds kh√¥ng h·ª£p l·ªá" });
          }
        } else if (Array.isArray(userIds)) {
          parsed = userIds;
        }

        if (parsed.length > 0) {
          const inserts = parsed.map((userId) => ({
            notificationId: notification.id,
            userId,
            isRead: false,
          }));

          try {
            await NotificationUser.bulkCreate(inserts);
          } catch (err) {
            console.error("L·ªói khi t·∫°o NotificationUser:", err);
            return res
              .status(500)
              .json({ message: "T·∫°o user nh·∫≠n th√¥ng b√°o th·∫•t b·∫°i" });
          }
        }
      }

      return res
        .status(201)
        .json({ message: "T·∫°o th√¥ng b√°o th√†nh c√¥ng", data: notification });
    } catch (err) {
      console.error("L·ªói t·∫°o th√¥ng b√°o:", err);
      return res
        .status(500)
        .json({ message: "L·ªói m√°y ch·ªß", error: err.message });
    }
  },

  async update(req, res) {
    try {
      const { id } = req.params;
      const {
        title,
        message,
        link,
        targetType,
        targetId,
        type,
        isActive,
        isGlobal,
        startAt,
        userIds,
        slug,
      } = req.body;

      const notification = await Notification.findByPk(id);
      const existing = await Notification.findOne({
        where: {
          title,
          id: { [Op.ne]: id },
        },
      });
      if (existing) {
        return res
          .status(400)
          .json({ message: "T√™n th√¥ng b√°o n√†y ƒë√£ t·ªìn t·∫°i" });
      }

      if (!notification)
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y th√¥ng b√°o" });

      const imageUrl = req.file?.path || notification.imageUrl;

      await notification.update({
        title,
        slug,
        message,
        imageUrl,
        link,
        targetType,
        targetId: targetId ? Number(targetId) : null,
        type,
        isActive: isActive === "true" || isActive === true,
        isGlobal: isGlobal === "true" || isGlobal === true,
        startAt: startAt ? new Date(startAt) : null,
      });

      // C·∫≠p nh·∫≠t danh s√°ch user nh·∫≠n th√¥ng b√°o n·∫øu isGlobal = false
      if (isGlobal === "false" || isGlobal === false || isGlobal === "0") {
        await NotificationUser.destroy({ where: { notificationId: id } });

        let parsed = [];

        if (typeof userIds === "string") {
          try {
            parsed = JSON.parse(userIds);
          } catch (err) {
            return res.status(400).json({ message: "userIds kh√¥ng h·ª£p l·ªá" });
          }
        } else if (Array.isArray(userIds)) {
          parsed = userIds;
        }

        if (parsed.length > 0) {
          const inserts = parsed.map((userId) => ({
            notificationId: id,
            userId,
            isRead: false,
          }));
          await NotificationUser.bulkCreate(inserts);
        }
      }

      return res.json({ message: "C·∫≠p nh·∫≠t th√†nh c√¥ng", data: notification });
    } catch (err) {
      console.error("L·ªói c·∫≠p nh·∫≠t:", err);
      return res
        .status(500)
        .json({ message: "L·ªói m√°y ch·ªß", error: err.message });
    }
  },

  async getAll(req, res) {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 10;
      const offset = (page - 1) * limit;

      const { search = "", isActive, type } = req.query;

      const where = {};

      if (search) {
        where[Op.or] = [
          { title: { [Op.like]: `%${search}%` } },
          { message: { [Op.like]: `%${search}%` } },
        ];
      }

      if (isActive !== undefined) {
        where.isActive = isActive === "true";
      }

      if (type) {
        where.type = type;
      }

      const { rows, count } = await Notification.findAndCountAll({
        where,
        offset,
        limit,
        order: [["createdAt", "DESC"]],
      });

      const allCount = await Notification.count();
      const activeCount = await Notification.count({
        where: { isActive: true },
      });
      const hiddenCount = await Notification.count({
        where: { isActive: false },
      });

      return res.status(200).json({
        data: rows,
        total: count,
        counts: {
          all: allCount,
          active: activeCount,
          hidden: hiddenCount,
        },
      });
    } catch (err) {
      console.error("L·ªói getAll notification:", err);
      return res.status(500).json({ message: "L·ªói m√°y ch·ªß" });
    }
  },

  async delete(req, res) {
    try {
      const { id } = req.params;
      const notification = await Notification.findByPk(id);

      if (!notification) {
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y th√¥ng b√°o" });
      }

      await notification.destroy();

      return res.json({ message: "ƒê√£ xo√° th√¥ng b√°o th√†nh c√¥ng" });
    } catch (err) {
      console.error("L·ªói xo√° th√¥ng b√°o:", err);
      return res.status(500).json({ message: "L·ªói m√°y ch·ªß" });
    }
  },

  async getById(req, res) {
    const { id } = req.params;
    const notification = await Notification.findByPk(id);
    if (!notification)
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y th√¥ng b√°o" });

    return res.json(notification);
  },

  async deleteMany(req, res) {
    try {
      const { ids } = req.body;

      if (!Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json({ message: "Danh s√°ch ID kh√¥ng h·ª£p l·ªá" });
      }

      await Notification.destroy({
        where: { id: ids },
        force: true,
      });

      return res.json({ message: "ƒê√£ xo√° th√†nh c√¥ng" });
    } catch (error) {
      console.error("L·ªói xo√° nhi·ªÅu:", error);
      return res.status(500).json({ message: "L·ªói m√°y ch·ªß" });
    }
  },

  async getBySlug(req, res) {
    try {
      const { slug } = req.params;
      const notification = await Notification.findOne({ where: { slug } });

      if (!notification) {
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y th√¥ng b√°o" });
      }

      return res.json(notification);
    } catch (err) {
      console.error("L·ªói getBySlug:", err);
      return res.status(500).json({ message: "L·ªói m√°y ch·ªß" });
    }
  },

  // async getByRole(req, res) {
  //   try {
  //     const userId = req.user.id;
  //     const roleId = req.user.roleId || req.user.roles?.[0]?.id;

  //     console.log("üîê USER:", req.user);
  //     console.log("üîé Extracted roleId:", roleId);

  //     if (!roleId) {
  //       return res.status(403).json({ message: "Thi·∫øu roleId" });
  //     }

  //     // üéØ Ch·ªâ cho c√°c role: Admin, Sales, K·∫ø to√°n (roleId 1, 3, 5)
  //     if (![1, 3, 5].includes(roleId)) {
  //       return res.json([]);
  //     }

  //     // ‚úÖ Th√¥ng b√°o g√°n tr·ª±c ti·∫øp qua NotificationUser
  //     let notificationTypeFilter = {};

  //     if (roleId === 5) {
  //       notificationTypeFilter.type = "order";
  //     } else if (roleId === 3) {
  //       notificationTypeFilter.type = "system";
  //     }

  //     const notiUsers = await NotificationUser.findAll({
  //       where: { userId },
  //       include: [
  //         {
  //           model: Notification,
  //           where: {
  //             isActive: true,
  //             ...notificationTypeFilter,
  //           },
  //           required: true,
  //         },
  //       ],
  //     });

  //     const notiFromUsers = notiUsers.map((n) => ({
  //       ...n.Notification.toJSON(),
  //       isRead: n.isRead,
  //       source: "user",
  //     }));

  //     // ‚úÖ Th√¥ng b√°o global theo role
  //     let globalNotifications = [];

  //     if (roleId === 1) {
  //       globalNotifications = await Notification.findAll({
  //         where: { isGlobal: true, isActive: true },
  //       });
  //     } else if (roleId === 5) {
  //       globalNotifications = await Notification.findAll({
  //         where: {
  //           isGlobal: true,
  //           isActive: true,
  //           type: "order",
  //         },
  //       });
  //     } else if (roleId === 3) {
  //       globalNotifications = await Notification.findAll({
  //         where: {
  //           isGlobal: true,
  //           isActive: true,
  //           type: "system",
  //         },
  //       });
  //     }

  //     const notiFromGlobal = globalNotifications.map((n) => ({
  //       ...n.toJSON(),
  //       isRead: false,
  //       source: "global",
  //     }));

  //     // ‚úÖ G·ªôp v√† s·∫Øp x·∫øp
  //     const result = [...notiFromUsers, ...notiFromGlobal];
  //     result.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

  //     // ‚úÖ Log k·∫øt qu·∫£
  //     console.log("üì• T·ªïng th√¥ng b√°o g·ª≠i v·ªÅ:", result.length);
  //     result.forEach((n) =>
  //       console.log(
  //         `üìå [${n.source.toUpperCase()}] ${n.title} | type: ${
  //           n.type
  //         } | isRead: ${n.isRead}`
  //       )
  //     );

  //     return res.json(result);
  //   } catch (err) {
  //     console.error("‚ùå L·ªói getByRole:", err);
  //     return res.status(500).json({ message: "L·ªói m√°y ch·ªß" });
  //   }
  // },
async getByRole(req, res) {
  try {
    const userId = req.user.id;
    const roleId = req.user.roleId || req.user.roles?.[0]?.id;

    if (!roleId) {
      return res.status(403).json({ message: "Thi·∫øu roleId" });
    }

    if (![1, 3, 5].includes(roleId)) {
      return res.json([]);
    }

    let notificationTypeFilter = {};

    if (roleId === 5) {
      notificationTypeFilter.type = "order";
    } else if (roleId === 3) {
      notificationTypeFilter.type = "system";
    }

    const notiUsers = await NotificationUser.findAll({
      where: { userId },
      include: [
        {
          model: Notification,
          where: {
            isActive: true,
            ...notificationTypeFilter,
          },
          required: true,
        },
      ],
    });

    const notiFromUsers = notiUsers.map((n) => ({
      ...n.Notification.toJSON(),
      isRead: n.isRead,
      source: "user",
    }));

    // L·∫•y global notifications
    let globalNotifications = [];

    if (roleId === 1) {
      globalNotifications = await Notification.findAll({
        where: { isGlobal: true, isActive: true },
      });
    } else if (roleId === 5) {
      globalNotifications = await Notification.findAll({
        where: {
          isGlobal: true,
          isActive: true,
          type: "order",
        },
      });
    } else if (roleId === 3) {
      globalNotifications = await Notification.findAll({
        where: {
          isGlobal: true,
          isActive: true,
          type: "system",
        },
      });
    }

    // Map global notifications c√≥ ki·ªÉm tra isRead d·ª±a tr√™n NotificationUser
    const notiFromGlobal = await Promise.all(
      globalNotifications.map(async (n) => {
        const record = await NotificationUser.findOne({
          where: {
            notificationId: n.id,
            userId,
          },
        });
        return {
          ...n.toJSON(),
          isRead: record ? record.isRead : false,
          source: "global",
        };
      })
    );

    // G·ªôp 2 m·∫£ng v√† l·ªçc duplicate notification theo id
    const combined = [...notiFromUsers, ...notiFromGlobal];

    const map = new Map();
    for (const n of combined) {
      if (!map.has(n.id)) {
        map.set(n.id, n);
      }
    }

    const result = Array.from(map.values()).sort(
      (a, b) => new Date(b.createdAt) - new Date(a.createdAt)
    );

    return res.json(result);
  } catch (err) {
    console.error("‚ùå L·ªói getByRole:", err);
    return res.status(500).json({ message: "L·ªói m√°y ch·ªß" });
  }
},


async markAsRead(req, res) {
  try {
    const { id } = req.params; // notificationId
    const userId = req.user?.id;

    if (!id || !userId) {
      return res.status(400).json({ message: 'Thi·∫øu th√¥ng tin' });
    }

    // T√¨m ho·∫∑c t·∫°o b·∫£n ghi notificationUser
    const [record, created] = await NotificationUser.findOrCreate({
      where: { notificationId: id, userId },
      defaults: { isRead: true, readAt: new Date() },
    });

    // N·∫øu b·∫£n ghi ƒë√£ t·ªìn t·∫°i nh∆∞ng ch∆∞a ƒë·ªçc th√¨ update
    if (!created && !record.isRead) {
      record.isRead = true;
      record.readAt = new Date();
      await record.save();
    }

    return res.json({ message: 'ƒê√£ ƒë√°nh d·∫•u l√† ƒë√£ ƒë·ªçc' });
  } catch (error) {
    console.error('L·ªói markAsRead:', error);
    return res.status(500).json({ message: 'L·ªói m√°y ch·ªß' });
  }
},
async markAllAsRead(req, res) {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ message: "Thi·∫øu th√¥ng tin ng∆∞·ªùi d√πng" });
    }

    // L·∫•y t·∫•t c·∫£ th√¥ng b√°o global, active c√πng tr·∫°ng th√°i ƒë√£ ƒë·ªçc c·ªßa user
    const globalNotifications = await Notification.findAll({
      where: {
        isGlobal: true,
        isActive: true,
      },
      include: [
        {
          model: NotificationUser,
          as: "notificationUsers",  // PH·∫¢I C√ì alias ƒë√∫ng
          required: false,
          where: { userId },
          attributes: ["id", "isRead", "readAt"],
        },
      ],
    });

    const toUpdateIds = [];
    const toInsertData = [];

    globalNotifications.forEach((notification) => {
      const record = notification.notificationUsers?.[0];
      if (record) {
        if (!record.isRead) {
          toUpdateIds.push(record.id);
        }
      } else {
        toInsertData.push({
          notificationId: notification.id,
          userId,
          isRead: true,
          readAt: new Date(),
        });
      }
    });

    if (toInsertData.length > 0) {
      await NotificationUser.bulkCreate(toInsertData);
    }

    if (toUpdateIds.length > 0) {
      await NotificationUser.update(
        { isRead: true, readAt: new Date() },
        { where: { id: toUpdateIds } }
      );
    }

    return res.status(200).json({ message: "ƒê√£ ƒë√°nh d·∫•u t·∫•t c·∫£ l√† ƒë√£ ƒë·ªçc" });
  } catch (err) {
    console.error("‚ùå markAllAsRead error:", err);
    return res.status(500).json({ message: "L·ªói m√°y ch·ªß khi ƒë√°nh d·∫•u ƒë√£ ƒë·ªçc" });
  }
}



};
module.exports = NotificationController;
