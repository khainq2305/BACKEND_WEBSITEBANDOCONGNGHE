// src/controllers/admin/orderController.js

const {
  Order,
  User,
  UserAddress,
  Province,
  ReturnRequest,
  RefundRequest,
  FlashSaleItem,
  District,
  ShippingProvider,
  Ward,
  PaymentMethod,
  OrderItem,
  sequelize,
  Sku,
  Product
} = require('../../models');
const refundGateway = require('../../utils/refundGateway');
const { Sequelize, Op } = require('sequelize');
const returnStock = async (orderItems, t) => {
  for (const it of orderItems) {
    await Sku.increment('stock', {
      by: it.quantity,
      where: { id: it.skuId },
      transaction: t,
    });

    const fsItem = it.Sku?.flashSaleSkus?.[0];
    if (fsItem) {
      await FlashSaleItem.increment('quantity', {
        by: it.quantity,
        where: { id: fsItem.id },
        transaction: t,
      });
    }
  }
};

class OrderController {
 static async getAll(req, res) {
  try {
    const { page = 1, limit = 10, search = '', status = '' } = req.query;
    const offset = (page - 1) * limit;

    const whereClause = {};
    if (status) {
      whereClause.status = status;
    }

    // ‚ö†Ô∏è Kh√¥ng ƒë·ªÉ '$User.fullName$' trong where khi subQuery = true (m·∫∑c ƒë·ªãnh)
    if (search) {
      whereClause[Op.or] = [
        { orderCode: { [Op.like]: `%${search}%` } },
        // ‚úÖ d√πng Sequelize.literal n·∫øu c·∫ßn v·∫´n gi·ªØ ·ªü ƒë√¢y, ho·∫∑c d√πng having b√™n d∆∞·ªõi
        Sequelize.literal(`User.fullName LIKE '%${search}%'`)
      ];
    }

    const includeClause = [
      {
        model: User,
        attributes: ['id', 'fullName', 'email', 'phone'],
        required: false
      },
      {
        model: UserAddress,
        as: 'shippingAddress',
        attributes: ['streetAddress', 'fullName', 'phone'],
        include: [
          { model: Province, as: 'province', attributes: ['name'] },
          { model: District, as: 'district', attributes: ['name'] },
          { model: Ward, as: 'ward', attributes: ['name'] }
        ]
      },
      {
  model: PaymentMethod,
  as: 'paymentMethod',
  attributes: ['name', 'code'] // üëà th√™m "code" ·ªü ƒë√¢y
}
,
      {
        model: OrderItem,
        as: 'items',
        include: [
          {
            model: Sku,
            include: [
              {
                model: Product,
                as: 'product',
                attributes: ['name']
              }
            ]
          }
        ]
      }
    ];

    const { count, rows } = await Order.findAndCountAll({
      subQuery: false, // ‚úÖ CH√åA KH√ìA ƒë·ªÉ tr√°nh l·ªói subquery ch∆∞a join b·∫£ng User
      where: whereClause,
      include: includeClause,
      order: [['createdAt', 'DESC']],
      offset: parseInt(offset),
      limit: parseInt(limit),
      distinct: true
    });
const formattedOrders = rows.map((o) => ({
  id               : o.id,
  code             : o.orderCode,
  customer         : o.User?.fullName || '‚Äî',
  total            : o.totalPrice || 0,
  status           : o.status,           // tr·∫°ng th√°i giao h√†ng
  paymentStatus    : o.paymentStatus,    // tr·∫°ng th√°i thanh to√°n
  paymentMethodCode: o.paymentMethod?.code || null, // ‚úÖ th√™m d√≤ng n√†y
  createdAt        : o.createdAt
}));



    return res.json({
      totalItems: count,
      totalPages: Math.ceil(count / limit),
      data: formattedOrders
    });
  } catch (error) {
    console.error('L·ªói l·∫•y danh s√°ch ƒë∆°n h√†ng:', error);
    return res.status(500).json({
      message: 'L·ªói server khi l·∫•y danh s√°ch ƒë∆°n h√†ng'
    });
  }
}

 static async getDetail(req, res) {
    try {
      const { id } = req.params;

      const order = await Order.findOne({
        where: { id },
        include: [
          {
            model: User,
            attributes: ['id', 'fullName', 'email', 'phone']
          },
          {
            model: UserAddress,
            as: 'shippingAddress',
            attributes: ['streetAddress', 'fullName', 'phone'],
            include: [
              { model: Province, as: 'province', attributes: ['name'] },
              { model: District, as: 'district', attributes: ['name'] },
              { model: Ward, as: 'ward', attributes: ['name'] }
            ]
          },
          {
            model: PaymentMethod,
            as: 'paymentMethod',
            attributes: ['id', 'name', 'code']
          },
          {
  model: ShippingProvider,
  as: 'shippingProvider',
  attributes: ['id', 'name', 'code']
},

          {
            model: OrderItem,
            as: 'items',
            include: [
              {
                model: Sku,
                attributes: ['id', 'price', 'originalPrice'],
                include: [
                  {
                    model: Product,
                    as: 'product',
                    attributes: ['id', 'name', 'thumbnail']
                  }
                ]
              }
            ]
          }
        ]
      });

      if (!order) {
        return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
      }

      return res.json(order);
    } catch (error) {
      console.error('L·ªói khi l·∫•y chi ti·∫øt ƒë∆°n h√†ng:', error);
      return res.status(500).json({ message: 'L·ªói server khi l·∫•y chi ti·∫øt ƒë∆°n h√†ng' });
    }
  }
// controllers/client/orderController.js
static async cancelOrder(req, res) {
  const t = await sequelize.transaction();
  try {
    /* --------- 0. Input --------- */
    const { id }     = req.params;
    const { reason } = req.body || {};

    if (!reason?.trim()) {
      return res.status(400).json({ message: 'L√Ω do hu·ª∑ ƒë∆°n kh√¥ng ƒë∆∞·ª£c b·ªè tr·ªëng' });
    }

    /* --------- 1. L·∫•y ƒë∆°n + items + sku + flashSaleItem --------- */
    const order = await Order.findOne({
      where: { id },
      include: [{
        model : OrderItem,
        as    : 'items',
        include: [{
          model : Sku,
          required: true,
          include: {
            model : FlashSaleItem,
            as    : 'flashSaleSkus',      // alias b·∫°n ƒë√£ khai b√°o
            required: false
          }
        }]
      }],
      transaction: t,
      lock: t.LOCK.UPDATE
    });

    if (!order)                 return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
    if (order.status === 'cancelled')
      return res.status(400).json({ message: 'ƒê∆°n h√†ng ƒë√£ hu·ª∑' });
    if (['delivered', 'completed'].includes(order.status))
      return res.status(400).json({ message: 'Kh√¥ng th·ªÉ hu·ª∑ ƒë∆°n ƒë√£ giao ho·∫∑c ho√†n th√†nh' });

    /* --------- 2. Tr·∫£ t·ªìn kho / flash sale --------- */
    for (const it of order.items) {
      /* 2.1 SKU */
      await Sku.increment('stock', {
        by : it.quantity,
        where: { id: it.skuId },
        transaction: t
      });

      /* 2.2 Flash Sale (n·∫øu c√≥) */
      const fsItem = it.Sku.flashSaleSkus?.[0];
      if (fsItem) {
        await FlashSaleItem.increment('quantity', {
          by : it.quantity,
          where: { id: fsItem.id },
          transaction: t
        });
      }
    }

    /* --------- 3. Tr·∫£ l∆∞·ª£t d√πng coupon (n·∫øu gi·ªõi h·∫°n) --------- */
    if (order.couponId) {
      await Coupon.increment('totalQuantity', {
        by : 1,
        where: { id: order.couponId },
        transaction: t
      });
    }

    /* --------- 4. C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n --------- */
    order.status        = 'cancelled';
    order.paymentStatus = 'unpaid';      // hu·ª∑ ‚áí coi nh∆∞ ch∆∞a thanh to√°n
    order.cancelReason  = reason.trim();
    await order.save({ transaction: t });

    await t.commit();
    return res.json({
      message: 'Hu·ª∑ ƒë∆°n & ho√†n kho th√†nh c√¥ng',
      orderId: order.id
    });

  } catch (err) {
    await t.rollback();
    console.error('[cancelOrder]', err);
    return res.status(500).json({ message: 'L·ªói server khi hu·ª∑ ƒë∆°n' });
  }
}

 static async updatePaymentStatus(req, res) {
    const t = await sequelize.transaction();
    try {
      const { id } = req.params;
      const { paymentStatus } = req.body;

      if (!paymentStatus) {
        return res
          .status(400)
          .json({ message: 'Thi·∫øu tr·∫°ng th√°i thanh to√°n c·∫ßn c·∫≠p nh·∫≠t' });
      }

      const order = await Order.findByPk(id, {
        transaction: t,
        lock: t.LOCK.UPDATE,
      });
      if (!order) {
        await t.rollback();
        return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
      }

      // Ch·ªâ cho ph√©p chuy·ªÉn t·ª´ 'waiting' ho·∫∑c 'unpaid' sang 'paid'
      // ƒê√¢y l√† n∆°i b·∫°n ƒë·ªãnh nghƒ©a logic chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i thanh to√°n th·ªß c√¥ng.
      if (!['waiting', 'unpaid'].includes(order.paymentStatus)) {
        await t.rollback();
        return res.status(400).json({
          message: 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n cho ƒë∆°n h√†ng n√†y',
        });
      }

      if (paymentStatus === 'paid') {
        order.paymentStatus = 'paid';
        // C√≥ th·ªÉ th√™m logic kh√°c ·ªü ƒë√¢y n·∫øu c·∫ßn, v√≠ d·ª•:
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng n·∫øu n√≥ ƒëang ·ªü 'processing' v√† b√¢y gi·ªù ƒë√£ thanh to√°n
        if (order.status === 'processing') {
          // B·∫°n c√≥ th·ªÉ ch·ªçn chuy·ªÉn sang 'confirmed' ho·∫∑c gi·ªØ 'processing' t√πy quy tr√¨nh c·ªßa b·∫°n
          // order.status = 'confirmed';
        }

        await order.save({ transaction: t });
        await t.commit();
        return res.json({
          message: 'C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n th√†nh c√¥ng',
          paymentStatus: order.paymentStatus,
        });
      } else {
        await t.rollback();
        return res
          .status(400)
          .json({ message: 'Tr·∫°ng th√°i thanh to√°n kh√¥ng h·ª£p l·ªá' });
      }
    } catch (error) {
      await t.rollback();
      console.error('L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n:', error);
      return res
        .status(500)
        .json({ message: 'L·ªói server khi c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n' });
    }
  }
static async updateStatus(req, res) {
  try {
    const { id } = req.params;
    const { status } = req.body;            // ‚¨Ö tr·∫°ng th√°i m·ªõi

    if (!status) {
      return res.status(400).json({ message: 'Thi·∫øu tr·∫°ng th√°i c·∫ßn c·∫≠p nh·∫≠t' });
    }

    const order = await Order.findByPk(id);
    if (!order) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       1. Kh√¥ng cho c·∫≠p nh·∫≠t nh·ªØng tr·∫°ng th√°i ‚Äúch·ªët‚Äù
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (['completed', 'cancelled'].includes(order.status)) {
      return res.status(400).json({ message: 'ƒê∆°n h√†ng ƒë√£ k·∫øt th√∫c, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t' });
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       2. Kh√¥ng ƒë∆∞·ª£c c·∫≠p nh·∫≠t n·∫øu tr√πng tr·∫°ng th√°i
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (order.status === status) {
      return res.status(400).json({ message: 'ƒê∆°n h√†ng ƒë√£ ·ªü tr·∫°ng th√°i n√†y' });
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       3. ƒê·ªãnh nghƒ©a lu·ªìng chuy·ªÉn ti·∫øp h·ª£p l·ªá
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    const forwardFlow = {
      processing: ['shipping', 'cancelled'],        // x·ª≠ l√Ω xong ‚Üí giao / hu·ª∑
      shipping  : ['delivered', 'cancelled'],       // ƒëang giao  ‚Üí ƒë√£ giao / hu·ª∑
      delivered : ['completed'],                    // giao xong  ‚Üí ho√†n th√†nh
    };

    const nextAllowed = forwardFlow[order.status] || [];

    if (!nextAllowed.includes(status)) {
      return res.status(400).json({ 
        message: `Kh√¥ng th·ªÉ chuy·ªÉn t·ª´ "${order.status}" sang "${status}"` 
      });
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       4. C·∫≠p nh·∫≠t & tr·∫£ v·ªÅ
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    order.status = status;
    await order.save();

    return res.json({ 
      message: 'C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng',
      status : order.status 
    });

  } catch (error) {
    console.error('L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng:', error);
    return res.status(500).json({ message: 'L·ªói server khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng' });
  }
}

static async getReturnByOrder(req, res) {
  try {
    const { orderId } = req.params;
    const requests = await ReturnRequest.findAll({
      where: { orderId },
      order: [['createdAt', 'DESC']]
    });

    return res.json({ data: requests });
  } catch (error) {
    console.error('L·ªói khi l·∫•y y√™u c·∫ßu tr·∫£ h√†ng:', error);
    return res.status(500).json({ message: 'L·ªói server' });
  }
}
 static async updateReturnStatus(req, res) {
    const t = await sequelize.transaction();
    try {
      const { id } = req.params;
      const { status, responseNote } = req.body;

      // ‚úÖ L·∫•y y√™u c·∫ßu tr·∫£ h√†ng + ƒë∆°n + item + SKU + flashSale n·∫øu c√≥
      const request = await ReturnRequest.findByPk(id, {
        include: {
          model: Order,
          as: 'order',
          include: {
            model: OrderItem,
            as: 'items',
            include: {
              model: Sku,
              include: { model: FlashSaleItem, as: 'flashSaleSkus', required: false }
            }
          }
        },
        transaction: t,
        lock: t.LOCK.UPDATE
      });

      if (!request) {
        await t.rollback();
        return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu' });
      }

      // ‚úÖ Ki·ªÉm tra tr·∫°ng th√°i chuy·ªÉn ti·∫øp h·ª£p l·ªá
      const flow = {
        pending: ['approved', 'rejected'],
        approved: ['awaiting_pickup', 'pickup_booked'],
        awaiting_pickup: ['received'],
        pickup_booked: ['received'],
        received: ['refunded'],
      };
      const next = flow[request.status] || [];
      if (!next.includes(status)) {
        await t.rollback();
        return res.status(400).json({ message: `Kh√¥ng th·ªÉ chuy·ªÉn ${request.status} ‚Üí ${status}` });
      }

      // ‚úÖ N·∫øu chuy·ªÉn sang received ‚Üí ho√†n kho + sinh y√™u c·∫ßu ho√†n ti·ªÅn
      if (status === 'received') {
        await returnStock(request.order.items, t);

   await RefundRequest.create({
  orderId : request.orderId,
  userId  : request.order.userId, // üëà th√™m d√≤ng n√†y
  amount  : request.order.finalPrice,
  reason  : 'Ho√†n ti·ªÅn th·ªß c√¥ng',
  status  : 'pending'
}, { transaction: t });

      }

      // ‚úÖ C·∫≠p nh·∫≠t tr·∫°ng th√°i y√™u c·∫ßu
      request.status = status;
      request.responseNote = responseNote;
      await request.save({ transaction: t });

      await t.commit();
      return res.json({ message: 'C·∫≠p nh·∫≠t tr·∫°ng th√°i tr·∫£ h√†ng th√†nh c√¥ng', data: request });

    } catch (error) {
      await t.rollback();
      console.error('[updateReturnStatus]', error);
      return res.status(500).json({ message: 'L·ªói server khi c·∫≠p nh·∫≠t tr·∫°ng th√°i' });
    }
  }
static async getRefundByOrder(req, res) {
  try {
    const { orderId } = req.params;

    const refunds = await RefundRequest.findAll({
      where: { orderId },
      order: [['createdAt', 'DESC']]
    });

    return res.json({ data: refunds });
  } catch (error) {
    console.error('L·ªói khi l·∫•y y√™u c·∫ßu ho√†n ti·ªÅn:', error);
    return res.status(500).json({ message: 'L·ªói server' });
  }
}
// PATCH /admin/refund-requests/:id
// controllers/admin/orderController.js
// ...
static async updateRefundStatus(req, res) {
  const t = await sequelize.transaction();
  try {
    const { id } = req.params;
    const { status, responseNote } = req.body; // 'refunded' | 'rejected'

    console.log('‚úÖ INPUT:', { id, status, responseNote });

    // 1Ô∏è‚É£ L·∫•y refund + order + payment method
    const refund = await RefundRequest.findByPk(id, {
      include: [{
        model: Order,
        as: 'order',
        include: [
          { model: PaymentMethod, as: 'paymentMethod', attributes: ['code'] },
          { model: ReturnRequest, as: 'returnRequest', required: false }
        ]
      }],
      lock: t.LOCK.UPDATE,
      transaction: t,
    });

    if (!refund) {
      console.log('‚ùå Kh√¥ng t√¨m th·∫•y RefundRequest');
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu ho√†n ti·ªÅn' });
    }

    console.log('‚úÖ RefundRequest:', refund.toJSON());
    console.log('‚úÖ Order:', refund.order?.toJSON());
    console.log('‚úÖ PaymentMethod:', refund.order?.paymentMethod?.code);

    if (refund.status === 'refunded') {
      console.log('‚ö†Ô∏è Y√™u c·∫ßu ƒë√£ ƒë∆∞·ª£c ho√†n ti·ªÅn tr∆∞·ªõc ƒë√≥');
      return res.status(400).json({ message: 'Y√™u c·∫ßu ƒë√£ ƒë∆∞·ª£c ho√†n ti·ªÅn tr∆∞·ªõc ƒë√≥' });
    }

    // 2Ô∏è‚É£ N·∫øu admin ch·ªçn tr·∫°ng th√°i ‚Äúrefunded‚Äù ‚Üí g·ªçi c·ªïng thanh to√°n
    if (status === 'refunded') {
      const payCode = refund.order.paymentMethod?.code?.toLowerCase() || '';
      console.log('‚úÖ payCode:', payCode);

      if (['vnpay', 'momo'].includes(payCode)) {
        const payload = {
          orderCode: refund.order.orderCode,
          amount: refund.amount,
        };

        if (payCode === 'momo') {
          console.log('‚úÖ momoTransId:', refund.order.momoTransId);
          if (!refund.order.momoTransId) {
            console.log('‚ùå Thi·∫øu momoTransId');
            await t.rollback();
            return res.status(400).json({
              message: 'ƒê∆°n h√†ng ch∆∞a l∆∞u momoTransId, kh√¥ng th·ªÉ ho√†n ti·ªÅn t·ª± ƒë·ªông',
            });
          }
          payload.momoTransId = refund.order.momoTransId;
        }

// üëá Th√™m v√†o n·∫øu l√† VNPay
if (payCode === 'vnpay') {
  if (!refund.order.vnpTransactionId || !refund.order.paymentTime) {
    console.log('‚ùå Thi·∫øu vnpTransactionId ho·∫∑c paymentTime');
    await t.rollback();
    return res.status(400).json({
      message: 'Thi·∫øu th√¥ng tin giao d·ªãch VNPay, kh√¥ng th·ªÉ ho√†n ti·ªÅn',
    });
  }

  payload.vnpTransactionId = refund.order.vnpTransactionId;
  payload.transDate = refund.order.paymentTime;
}

        console.log('üöÄ G·ªçi refundGateway v·ªõi payload:', payload);

        const { ok, transId } = await refundGateway(payCode, payload);

        console.log('‚úÖ K·∫øt qu·∫£ refundGateway:', { ok, transId });

        if (!ok) {
          console.log('‚ùå Ho√†n ti·ªÅn qua c·ªïng thanh to√°n th·∫•t b·∫°i');
          await t.rollback();
          return res.status(400).json({ message: 'Ho√†n ti·ªÅn qua c·ªïng thanh to√°n th·∫•t b·∫°i' });
        }

        refund.gatewayTransId = transId || null;
      }

      // 3Ô∏è‚É£ C·∫≠p nh·∫≠t Order & ReturnRequest (n·∫øu c√≥)
      refund.order.paymentStatus = 'refunded';
      await refund.order.save({ transaction: t });

      if (refund.order.returnRequest) {
        refund.order.returnRequest.status = 'refunded';
        await refund.order.returnRequest.save({ transaction: t });
      }
    }

    // 4Ô∏è‚É£ L∆∞u RefundRequest
    refund.status = status;
    refund.responseNote = responseNote || null;
    await refund.save({ transaction: t });

    console.log('‚úÖ RefundRequest updated:', refund.toJSON());

    await t.commit();
    return res.json({ message: 'C·∫≠p nh·∫≠t tr·∫°ng th√°i ho√†n ti·ªÅn th√†nh c√¥ng', data: refund });

  } catch (err) {
    await t.rollback();
    console.error('[updateRefundStatus] ‚ùå L·ªói:', err);
    return res.status(500).json({ message: 'L·ªói server khi c·∫≠p nh·∫≠t ho√†n ti·ªÅn' });
  }
}

// ...

}

module.exports = OrderController;
